# 场景一：AI生视频 (Video Generation)

#### 为什么视频生成这么难？

视频提示词的核心逻辑必须从 **画面描述** 升级为 **状态控制指令**。你必须显式定义 **主体、动作、运镜、光影、物理属性** 这五个维度的参数。

A medium shot of a cyberpunk samurai standing on a neon-lit rooftop at night. Rain is falling heavily. The samurai unsheathes a glowing katana slowly (Action). The camera dollys in on the face while panning slightly right (Camera). Cyberpunk style, cinematic lighting, 8k resolution, high fidelity.

一个中景镜头，表现一个赛博朋克武士站在夜晚霓虹灯照亮的屋顶上。雨下得很大。武士缓缓拔出一把发光的武士刀（动作）。镜头在轻微向右移动的同时拉近他的脸（摄影）。赛博朋克风格，电影感灯光，8K 分辨率，高保真。
![[场景1-1.mp4]]
```Plain
{
  "shot_type": "Medium Close-up",
  "subject": {
    "description": "Beautiful woman, Heart-shaped face,Long black hair,Big eyes, D-cup, deep cleavage",
    "clothing": "Pink dress",
    "consistency_anchor": "Reference_ID_01" 
  },
  "action": {
    "primary": "Looking at the camera with teary eyes",
    "secondary": "Arms naturally hanging down",
    "physics": "Light and shadow naturally"
  },
  "camera": {
    "movement": "Slowly zoom in",
    "focus": "From overall to focusing on the eyes",
    "stability": "High"
  },
  "environment": {
    "location": "A bright, sunlit sea of flowers",
    "particles": "The petals dance in the beams of light"
  },
  "style": "Arri Alexa, Kodak Portra 400 grain"
}
```
![[场景1-2.mp4]]
一个阿凡达，骑着末影，飞行在上海外滩
![[场景1-3.mp4]]

阿凡达2男主，骑着他的专属座驾末影，背后背着弓箭，手里拿着机枪，飞行在上海外滩侦查

# 场景二：AI 生图 (Image Generation)

**Change** the background to a snowy mountain peak. **Keep** the subject's lighting and pose exactly the same. **Ensure** the snow reflects the ambient blue light.
![[场景2-1.png]]

**[Subject]** A translucent glass sculpture of a lion, intricate crystal texture, refraction visible. **[Environment]** Placed on a dark obsidian pedestal in a minimalist gallery. **[Lighting]** Sharp spotlight from above, creating caustic patterns on the floor. **[Camera]** Macro shot, 100mm lens, shallow depth of field focused on the lion's eye.
![[场景2-2.png]]为了获得极高的一致性（例如生成一组风格统一的图标或插画），不要凭空猜提示词。

策略是：先找一张风格参考图，让多模态模型（如 GPT-4o 或 Gemini）将其 **反编译** 为结构化的 JSON 提示词，修改 JSON 中的变量，再喂回生图模型。

**反编译 Prompt 示例：**

> Analyze this image and break it down into a JSON format with the following keys: "composition", "lighting", "color_palette", "subject_style", "negative_constraints".

{
  "composition": "A close-up photograph of a clear glass sculpture of a lion's head resting on a square, polished black pedestal. The pedestal is centered in the frame on a concrete floor. The background is a blurred, minimalist concrete room with vertical architectural elements in shadow. The camera angle is slightly elevated, looking down at the sculpture.",
  "lighting": "Dramatic, high-contrast lighting from a single, strong overhead spotlight. This creates intense specular highlights and refractions within the glass sculpture. It also casts complex, rainbow-colored caustic patterns onto the pedestal and the concrete floor around it. The background is largely in deep shadow.",
  "color_palette": "Dominantly monochromatic and cool tones. Clear, transparent glass with spectral rainbow refractions (red, orange, yellow, green, blue, violet). Deep black pedestal. Various shades of cool grey in the concrete floor and background.",
  "subject_style": "Realistic, highly detailed glass sculpture of a lion's head with a flowing mane. The glass has a textured surface and internal bubbles, emphasizing its material properties and light-refracting qualities. The style is sculptural and luxurious.",
  "negative_constraints": "No people, no other animals, no other objects besides the sculpture and pedestal. No bright colors in the background. No natural light source. The background is not in focus. No text or graphics."
}

这种方法的优势在于你可以固定 `style_reference` 字段，只修改 `subject` 字段，从而批量生产风格完全一致的图片。

{
  "composition": "一张特写照片，展示了一个清晰的拉布布玻璃雕塑，它安放在一个手办专用圆形黑色基座上。基座位于画面中心的大理石地面上。背景是一个模糊的、简约的艺术展厅，有处于阴影中的垂直建筑元素。相机角度略微抬高，向下俯视雕塑。",
  "lighting": "戏剧性的、高对比度的照明，来自单个强烈的头顶聚光灯。这在玻璃雕塑内部产生强烈的镜面高光和折射。它还在基座和周围的混凝土地面上投射出复杂的彩虹色焦散图案。背景大部分处于深阴影中。",
  "color_palette": "主要是单色和冷色调。透明的玻璃带有光谱彩虹折射（红、橙、黄、绿、蓝、紫），深黑色的基座。混凝土地面和背景呈现出各种冷灰色调。",
  "subject_style": "逼真、高度细节的拉布布雕塑，表情逼真。玻璃表面有纹理，内部有气泡，强调其材料特性和光折射品质。风格具有雕塑感和奢华感。",
  "negative_constraints": "没有人物，没有其他动物，除雕塑和基座外没有其他物体。背景中没有鲜艳的颜色。没有自然光源。背景不聚焦。没有文字或图形。"
}

![[场景2-3.png]]{
  "composition": "一张特写照片，展示了一个清晰的乌萨奇玻璃雕塑，它安放在一个手办专用圆形黑色基座上。基座位于画面中心的大理石地面上。背景是一个模糊的、简约的艺术展厅，有处于阴影中的垂直建筑元素。相机角度略微抬高，向下俯视雕塑。",
  "lighting": "戏剧性的、高对比度的照明，来自单个强烈的头顶聚光灯。这在玻璃雕塑内部产生强烈的镜面高光和折射。它还在基座和周围的混凝土地面上投射出复杂的彩虹色焦散图案。背景大部分处于深阴影中。",
  "color_palette": "主要是单色和冷色调。透明的玻璃带有光谱彩虹折射（红、橙、黄、绿、蓝、紫），深黑色的基座。混凝土地面和背景呈现出各种冷灰色调。",
  "subject_style": "逼真、高度细节的乌萨奇雕塑，表情逼真。玻璃表面有纹理，内部完整无气泡，强调其材料特性和光折射品质。风格具有雕塑感和奢华感。",
  "negative_constraints": "没有人物，没有其他动物，除雕塑和基座外没有其他物体。背景中没有鲜艳的颜色。没有自然光源。背景不聚焦。没有文字或图形。"
}
![[场景2-4.png]]
##没识别到乌萨奇是chiikawa漫画中的角色

我要的主体是 chiikaw漫画中的Usagi 而不是一只兔子，请修改
![[场景2-5.png]]

# 场景三：AI 编程 (AI Coding / Engineering)

1. ##### 上下文锚定与规则文件 (The .cursorrules / System Prompt)
    

不要在每次对话中重复你的技术栈。最佳实践是将项目规范写入 **系统级提示词**（在 Cursor 中是 `.cursorrules` 文件，在其他工具中是 Custom Instructions）。

**核心逻辑**：明确 **技术栈约束** 和 **代码风格**。

**实战模版（可直接复用于 .cursorrules）：**

> [Tech Stack]
> 
> Framework: Next.js 14 (App Router)
> 
> Language: TypeScript (Strict mode)
> 
> Styling: Tailwind CSS
> 
> State: Zustand
> 
> **[Style Guide]**
> 
> - Always use functional components with named exports.
>     
> - Use interfaces over types for object definitions.
>     
> - No `any` types; strictly define props.
>     
> - File names must use kebab-case (e.g., `user-profile.tsx`).
>     
> 
> **[Behavior]**
> 
> - When reading code, prioritize reading `package.json` first to understand dependencies.
>     
> - Never suggest deprecated APIs.


# 场景四：结构化提示词 (Structured JSON Prompting)

**JSON 提示词** 则是结构化的键值对信息。它通过 `{ Key: Value }` 的形式，强行将指令拆解为独立的模块。

**核心区别对比：**

- **自然语言 (NL)**：
    
> - 请帮我生成一段视频，画面是一个赛博朋克的武士在下雨的东京街头拔刀，镜头要慢动作推近，光线要霓虹感，不要有任何模糊。
>     
>     - _缺陷_：修饰词容易混淆（霓虹感是修饰街头还是修饰刀？），长难句容易导致模型漏掉“慢动作”这个指令。
>         
- **结构化提示词 (JSON)**：

```Plain
{
  "Subject": "Cyberpunk Samurai",
  "Action": "Unsheathing katana",
  "Environment": {
    "Location": "Tokyo Street",
    "Weather": "Heavy Rain"
  },
  "Camera": "Slow motion, Dolly In",
  "Lighting": "Neon ambiance",
  "Negative_Prompt": "Blurry, Low resolution"
}
```
![[场景4-1.mp4]]
#### 什么场景下最适合用 JSON 写提示词？

1. 高精度视频生成 (Sora 2 / Veo 3.1)：
    
视频包含主体、环境、运镜、物理规律等多个维度。用 JSON 可以确保模型不会把“镜头向左移”理解成“主角向左走”。

2. 批量化内容生产 (Programmatic SEO / Ads)：
    
当你需要生成 1000 条格式统一、但内容不同的广告文案时。你只需要固定 JSON 的结构（Schema），然后用脚本动态替换其中的变量（如产品名），即可保证输出质量的高度一致性。

3. 复杂角色扮演 (Complex Roleplay)：
    
需要维护复杂的角色状态时。例如：{"Current_Mood": "Angry", "Memory": ["Insulted by user"], "Goal": "Seek revenge"}。用 JSON 显式定义状态，比用自然语言描述“你现在很生气”更稳定。

4. API 对接与工作流自动化 (Agents)：
    
当提示词是自动化程序的一部分，需要被代码解析时。

#### 最佳实践与注意事项

##### 1. 键名即指令 (Semantic Keys)

JSON 的 Key（键名）不仅仅是标签，更是指令的一部分。不要使用 `a`, `b`, `c` 这种无意义的键名。

- **差**：`{ "a": "Samurai", "b": "Rain" }`
    
- **优**：`{ "Main_Subject_Visuals": "Samurai", "Environmental_Atmosphere": "Rain" }`
    

模型会阅读键名来理解 Value 的上下文。使用描述性的键名能起到 **强调 (Emphasis)** 的作用。

##### 2. 伪代码与注释 (Pseudo-code & Comments)

虽然标准的 JSON 不支持注释，但在提示词中，LLM 完全能读懂带注释的 JSON（如 JSON5 标准）。利用这一点来通过注释进行“微操”。

**实战模版：**

```Plain
{
  "Style": "Cinematic", // Ensure the look is like a high-budget movie"Camera_Movement": "Truck Left", // Do NOT rotate the camera, move physically left"Duration": "5s"
}
```

##### 3. 模块化复用 (Modularity)
建立一套通用的 JSON 模板库。你可以把 `Camera`、`Lighting`、`Style` 做成独立的 JSON 对象模块。在写新提示词时，只需要像搭积木一样组合这些模块。

##### 4. 避免过度嵌套 (Avoid Deep Nesting)

虽然 JSON 支持无限嵌套，但对于提示词，嵌套层级过深（超过 3-4 层）会稀释模型的注意力。保持结构扁平化是最佳策略。

- **避免**：`{ "Scene": { "Background": { "Details": { "Objects": [...] } } } }`
    
- **推荐**：`{ "Scene_Background": ..., "Background_Objects": ... }`
    

##### 5. 显式定义负向约束 (Negative Constraints within JSON)

在 JSON 中专门开辟一个字段用于“负向提示词”，往往比在自然语言最后加一句“不要xxx”效果更好。

```Plain
{
  "Task": "Generate an image",
  "Subject": "A cat",
  "Constraints": {
    "Forbidden_Elements": ["text", "watermark", "humans"],
    "Style_Restrictions": "No cartoon style, photorealistic only"
  }
}
```
![[场景4-2.png]]

{
  "Task": "Generate an image",
  "Subject": "labubu",
  "Constraints": {
    "Forbidden_Elements": ["text", "watermark", "humans"],
    "Style_Restrictions": "No cartoon style, photorealistic only"
  }
}
![[场景4-3.png]]

# 场景五：数据分析 (Data Analysis)

#### 为什么 AI 做数据分析容易“一本正经胡说八道”？

在数据分析场景中，LLM 最大的陷阱是 **计算幻觉** 和 **逻辑跳跃**。

LLM 的本质是文字接龙，它并不具备内置的逻辑计算单元。如果你问它“这列数据的平均值是多少？”，它往往不是去“算”，而是根据上下文“猜”一个数字。

常见的痛点包括：

1. **数值编造**：对于未明确给出的统计数据，AI 倾向于编造一个看起来合理的数字。
    
2. **代码假设错误**：AI 写 Python 代码时，经常假设某些列名（如 `date`）存在，但实际上数据集里的列名可能是 `timestamp_ms`，导致代码报错。
    
3. **缺乏上下文**：AI 不知道业务逻辑（例如：销售额 = 单价 * 数量，还是直接取 `total_sales` 列？），导致计算逻辑偏差。
    

因此，数据分析提示词的核心原则是 **强制工具调用 (Force Tool Use)** 和 **元数据注入 (Metadata Injection)**。

  #### 最佳实践与框架

基于 Microsoft Learn 和 Google AI 课程的讨论，以下四种策略能显著提升数据分析的准确性。

1. ##### 强制代码执行模式 (The Code-Execution Mandate)
    

这是数据分析的第一铁律：**永远不要让 LLM 直接回答数字，永远要求它写代码计算**。

对于 ChatGPT (Advanced Data Analysis) 或 Claude，必须显式指示其使用 Python/Pandas。

**实战模版：**

> [Role] You are a Senior Data Analyst.
> 
> [Constraint] Do NOT calculate anything manually. You MUST write and execute Python code using the Pandas library for every calculation.
> 
> [Task] Calculate the month-over-month growth rate of sales.
> 
> [Output] Show the Python code, the execution result, and then a brief summary text.

### 》》**月比销售增长分析**

作为高级数据分析师，我生成了一个合成数据集，代表每日销售交易。然后我将这些数据汇总为月度水平，并应用百分比变化函数来确定月比（MoM）增长率。

#### **1. Python 代码**

蟒蛇

```
import pandas as pd
import numpy as np

# --- Step 1: Generate Synthetic Data ---
# Creating a date range for 6 months
np.random.seed(42)  # For reproducible results
dates = pd.date_range(start='2024-01-01', end='2024-06-30', freq='D')
daily_sales = np.random.randint(1000, 5000, size=len(dates))

df = pd.DataFrame({
    'Date': dates,
    'Sales': daily_sales
})

# --- Step 2: Aggregation & Calculation ---
# 1. Set Date as index and resample to Month-End ('ME') to get total monthly sales
monthly_df = df.set_index('Date').resample('ME')['Sales'].sum().to_frame()

# 2. Calculate Month-over-Month Growth Rate using pct_change()
# Formula: (Current Month - Previous Month) / Previous Month
monthly_df['MoM_Growth'] = monthly_df['Sales'].pct_change()

# --- Step 3: Formatting Output ---
# Converting to percentage string for readability
monthly_df['MoM_Growth_Formatted'] = monthly_df['MoM_Growth'].apply(
    lambda x: f"{x:.2%}" if pd.notnull(x) else "N/A"
)

# Display the final dataframe
print(monthly_df[['Sales', 'MoM_Growth_Formatted']])
```

---

#### **2. 执行结果**

明文

```
            Sales MoM_Growth_Formatted
Date                                  
2024-01-31  94863                  N/A
2024-02-29  85731               -9.63%
2024-03-31  95292               11.15%
2024-04-30  86897               -8.81%
2024-05-31  93721                7.85%
2024-06-30  90455               -3.48%
```

---

#### **3. 摘要**

- **一月基线：**我们建立了一月份销售**额的基线为94,863**辆。
    
- **波动率：**数据显示表现波动。我们在二月份看到**了-9.63%**的下跌，很可能是因为该月较短，随后三月强劲回升至**+11.15%。**
    
- **近期趋势：**最近一个月（6月）收盘时，与五月相比略有**收缩3.48%。**